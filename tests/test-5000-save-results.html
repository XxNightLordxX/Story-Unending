<!DOCTYPE html>
<html>
<head>
    <title>Comprehensive Test 5000 Chapters - Save Results</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #1a1a2e; color: #eee; }
        .section { margin: 20px 0; padding: 15px; background: #16213e; border-radius: 8px; }
        .pass { color: #4ade80; }
        .fail { color: #f87171; }
        .warning { color: #fbbf24; }
        h1 { color: #60a5fa; }
        h2 { color: #a78bfa; }
        table { width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 11px; }
        th, td { padding: 5px; text-align: left; border-bottom: 1px solid #374151; }
        th { color: #60a5fa; }
        #progress { position: fixed; top: 10px; right: 10px; background: #1f2937; padding: 15px; border-radius: 8px; z-index: 1000; max-width: 350px; font-size: 12px; border: 3px solid #60a5fa; }
        #results { margin-top: 100px; }
        button { background: #60a5fa; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 14px; margin: 10px 5px; }
        button:hover { background: #3b82f6; }
    </style>
<script src="https://sites.super.myninja.ai/_assets/ninja-daytona-script.js"></script>
</head>
<body>
    <div id="progress">Click "Start Test" to begin</div>
    <h1>üß™ Comprehensive Test: 5000 Chapters</h1>
    <div>
        <button onclick="startTest()">Start Test</button>
        <button onclick="downloadResults()">Download Results</button>
    </div>
    <div id="results"></div>

    <script src="story-engine.js"></script>
    <script>
        const TOTAL_CHAPTERS = 5000;
        
        const results = {
            totalChapters: 0,
            duplicateTitles: [],
            duplicateParagraphs: [],
            wordCountIssues: [],
            arcProgression: [],
            statProgression: [],
            chapterTypes: {},
            settings: {},
            locations: [],
            performance: {
                startTime: null,
                endTime: null,
                duration: null
            },
            titleCounts: {},
            paragraphCounts: {},
            consecutiveDuplicates: 0,
            maxConsecutiveDuplicates: 0,
            lastTitle: null,
            completed: false
        };

        function updateProgress(current, total, message) {
            const progress = document.getElementById('progress');
            const percent = ((current / total) * 100).toFixed(1);
            const elapsed = ((Date.now() - results.performance.startTime) / 1000).toFixed(1);
            const avgTime = current > 0 ? (elapsed / current * 1000).toFixed(2) : '0.00';
            const eta = current > 0 ? ((total - current) * avgTime / 1000).toFixed(0) : '0';
            
            progress.innerHTML = `
                <strong>Progress:</strong> ${current}/${total} (${percent}%)<br>
                <strong>Status:</strong> ${message}<br>
                <strong>Time:</strong> ${elapsed}s<br>
                <strong>ETA:</strong> ${eta}s<br>
                <strong>Duplicates:</strong> ${Object.keys(results.titleCounts).filter(k => results.titleCounts[k] > 1).length}<br>
                <strong>Low WC:</strong> ${results.wordCountIssues.length}
            `;
        }

        function startTest() {
            if (results.completed) {
                alert('Test already completed. Click "Download Results" to save.');
                return;
            }
            
            console.log('Starting 5000 chapter test...');
            results.performance.startTime = Date.now();
            
            // Use setTimeout to allow UI to update
            setTimeout(() => {
                runTest();
            }, 100);
        }

        function runTest() {
            const batchSize = 100;
            let currentChapter = 0;
            
            function processBatch() {
                const batchEnd = Math.min(currentChapter + batchSize, TOTAL_CHAPTERS);
                
                for (let i = currentChapter + 1; i <= batchEnd; i++) {
                    const chapter = generateChapter(i);
                    results.totalChapters++;
                    
                    // Check for duplicate titles
                    if (results.titleCounts[chapter.title]) {
                        results.titleCounts[chapter.title]++;
                        
                        // Check for consecutive duplicates
                        if (chapter.title === results.lastTitle) {
                            results.consecutiveDuplicates++;
                            if (results.consecutiveDuplicates > results.maxConsecutiveDuplicates) {
                                results.maxConsecutiveDuplicates = results.consecutiveDuplicates;
                            }
                        } else {
                            results.consecutiveDuplicates = 1;
                        }
                    } else {
                        results.titleCounts[chapter.title] = 1;
                        results.duplicateTitles.push(chapter.title);
                        results.consecutiveDuplicates = 0;
                    }
                    results.lastTitle = chapter.title;
                    
                    // Check word count
                    if (chapter.wordCount < 1000) {
                        results.wordCountIssues.push({
                            chapter: i,
                            wordCount: chapter.wordCount,
                            title: chapter.title,
                            type: chapter.type,
                            setting: chapter.setting
                        });
                    }
                    
                    // Track paragraph duplicates
                    chapter.paragraphs.forEach(para => {
                        const paraHash = para.substring(0, 60);
                        if (results.paragraphCounts[paraHash]) {
                            results.paragraphCounts[paraHash]++;
                        } else {
                            results.paragraphCounts[paraHash] = 1;
                        }
                    });
                    
                    // Track chapter types
                    if (!results.chapterTypes[chapter.type]) {
                        results.chapterTypes[chapter.type] = 0;
                    }
                    results.chapterTypes[chapter.type]++;
                    
                    // Track settings
                    if (!results.settings[chapter.setting]) {
                        results.settings[chapter.setting] = 0;
                    }
                    results.settings[chapter.setting]++;
                    
                    // Track locations
                    if (!results.locations.includes(chapter.location)) {
                        results.locations.push(chapter.location);
                    }
                    
                    // Track arc progression
                    if (!results.arcProgression.includes(chapter.arc)) {
                        results.arcProgression.push(chapter.arc);
                    }
                    
                    // Track stat progression (sample every 100 chapters)
                    if (i % 100 === 0) {
                        results.statProgression.push({
                            chapter: i,
                            level: chapter.mcSnapshot.level,
                            hp: chapter.mcSnapshot.hp,
                            mp: chapter.mcSnapshot.mp,
                            bloodEssence: chapter.mcSnapshot.bloodEssence,
                            str: chapter.mcSnapshot.strength,
                            agi: chapter.mcSnapshot.agility,
                            int: chapter.mcSnapshot.intelligence
                        });
                    }
                }
                
                currentChapter = batchEnd;
                updateProgress(currentChapter, TOTAL_CHAPTERS, `Generated ${currentChapter} chapters...`);
                
                if (currentChapter < TOTAL_CHAPTERS) {
                    // Process next batch
                    setTimeout(processBatch, 10);
                } else {
                    // Test complete
                    results.performance.endTime = Date.now();
                    results.performance.duration = results.performance.endTime - results.performance.startTime;
                    results.completed = true;
                    updateProgress(TOTAL_CHAPTERS, TOTAL_CHAPTERS, 'Complete!');
                    displayResults();
                }
            }
            
            processBatch();
        }

        function displayResults() {
            const resultsDiv = document.getElementById('results');
            
            const duplicateTitles = Object.entries(results.titleCounts).filter(([_, count]) => count > 1);
            const duplicateTitleCount = duplicateTitles.reduce((sum, [_, count]) => sum + (count - 1), 0);
            
            const duplicateParagraphs = Object.entries(results.paragraphCounts).filter(([_, count]) => count > 1);
            const duplicateParagraphCount = duplicateParagraphs.reduce((sum, [_, count]) => sum + (count - 1), 0);
            
            const hasIssues = duplicateTitleCount > 0 || duplicateParagraphCount > 0 || results.wordCountIssues.length > 0 || results.maxConsecutiveDuplicates > 0;
            
            let html = `
                <div class="section">
                    <h2>üìä COMPREHENSIVE RESULTS</h2>
                    <table>
                        <tr><th>Metric</th><th>Value</th><th>Status</th></tr>
                        <tr><td>Total Chapters</td><td>${results.totalChapters}</td><td class="pass">‚úÖ</td></tr>
                        <tr><td>Unique Titles</td><td>${results.duplicateTitles.length}</td><td class="pass">‚úÖ</td></tr>
                        <tr><td>Duplicate Titles</td><td class="${duplicateTitleCount > 0 ? 'fail' : 'pass'}">${duplicateTitleCount}</td><td class="${duplicateTitleCount > 0 ? 'fail' : 'pass'}">${duplicateTitleCount > 0 ? '‚ùå' : '‚úÖ'}</td></tr>
                        <tr><td>Max Consecutive Duplicates</td><td class="${results.maxConsecutiveDuplicates > 0 ? 'fail' : 'pass'}">${results.maxConsecutiveDuplicates}</td><td class="${results.maxConsecutiveDuplicates > 0 ? 'fail' : 'pass'}">${results.maxConsecutiveDuplicates > 0 ? '‚ùå' : '‚úÖ'}</td></tr>
                        <tr><td>Unique Paragraphs</td><td>${Object.keys(results.paragraphCounts).length}</td><td class="pass">‚úÖ</td></tr>
                        <tr><td>Duplicate Paragraphs</td><td class="${duplicateParagraphCount > 0 ? 'fail' : 'pass'}">${duplicateParagraphCount}</td><td class="${duplicateParagraphCount > 0 ? 'fail' : 'pass'}">${duplicateParagraphCount > 0 ? '‚ùå' : '‚úÖ'}</td></tr>
                        <tr><td>Word Count Issues</td><td class="${results.wordCountIssues.length > 0 ? 'fail' : 'pass'}">${results.wordCountIssues.length}</td><td class="${results.wordCountIssues.length > 0 ? 'fail' : 'pass'}">${results.wordCountIssues.length > 0 ? '‚ùå' : '‚úÖ'}</td></tr>
                        <tr><td>Unique Arcs</td><td>${results.arcProgression.length}</td><td class="pass">‚úÖ</td></tr>
                        <tr><td>Chapter Types</td><td>${Object.keys(results.chapterTypes).length}</td><td class="pass">‚úÖ</td></tr>
                        <tr><td>Settings</td><td>${Object.keys(results.settings).length}</td><td class="pass">‚úÖ</td></tr>
                        <tr><td>Locations</td><td>${results.locations.length}</td><td class="pass">‚úÖ</td></tr>
                        <tr><td>Performance</td><td>${(results.performance.duration / 1000).toFixed(2)}s</td><td class="pass">‚úÖ</td></tr>
                        <tr><td>Avg Time/Chapter</td><td>${(results.performance.duration / TOTAL_CHAPTERS).toFixed(2)}ms</td><td class="pass">‚úÖ</td></tr>
                    </table>
                </div>
            `;
            
            if (duplicateTitles.length > 0) {
                html += `
                    <div class="section">
                        <h2 class="warning">‚ö†Ô∏è DUPLICATE TITLES (${duplicateTitles.length})</h2>
                        <table>
                            <tr><th>Title</th><th>Count</th></tr>
                `;
                duplicateTitles.slice(0, 30).forEach(([title, count]) => {
                    html += `<tr><td>"${title}"</td><td>${count}</td></tr>`;
                });
                html += `</table></div>`;
            }
            
            if (duplicateParagraphs.length > 0) {
                html += `
                    <div class="section">
                        <h2 class="warning">‚ö†Ô∏è DUPLICATE PARAGRAPHS (${duplicateParagraphs.length})</h2>
                        <table>
                            <tr><th>Paragraph (first 60 chars)</th><th>Count</th></tr>
                `;
                duplicateParagraphs.sort((a, b) => b[1] - a[1]).slice(0, 30).forEach(([para, count]) => {
                    html += `<tr><td>"${para}..."</td><td>${count}</td></tr>`;
                });
                html += `</table></div>`;
            }
            
            if (results.wordCountIssues.length > 0) {
                html += `
                    <div class="section">
                        <h2 class="warning">‚ö†Ô∏è WORD COUNT ISSUES (${results.wordCountIssues.length})</h2>
                        <table>
                            <tr><th>Chapter</th><th>Words</th><th>Type</th><th>Setting</th><th>Title</th></tr>
                `;
                results.wordCountIssues.slice(0, 50).forEach(issue => {
                    html += `<tr><td>${issue.chapter}</td><td>${issue.wordCount}</td><td>${issue.type}</td><td>${issue.setting}</td><td>"${issue.title}"</td></tr>`;
                });
                html += `</table></div>`;
            }
            
            html += `
                <div class="section">
                    <h2>${hasIssues ? '‚ö†Ô∏è ISSUES FOUND' : '‚úÖ ALL TESTS PASSED'}</h2>
                    ${!hasIssues ? 
                        '<p class="pass">‚úÖ No duplicate titles<br>‚úÖ No consecutive duplicates<br>‚úÖ No duplicate paragraphs<br>‚úÖ All chapters meet 1000 word minimum<br>‚úÖ All systems working correctly</p>' :
                        '<p class="fail">‚ö†Ô∏è Issues detected - see details above</p>'}
                </div>
            `;
            
            resultsDiv.innerHTML = html;
            console.log('Test complete!');
        }

        function downloadResults() {
            if (!results.completed) {
                alert('Please complete the test first by clicking "Start Test"');
                return;
            }
            
            const duplicateTitles = Object.entries(results.titleCounts).filter(([_, count]) => count > 1);
            const duplicateTitleCount = duplicateTitles.reduce((sum, [_, count]) => sum + (count - 1), 0);
            
            const duplicateParagraphs = Object.entries(results.paragraphCounts).filter(([_, count]) => count > 1);
            const duplicateParagraphCount = duplicateParagraphs.reduce((sum, [_, count]) => sum + (count - 1), 0);
            
            const hasIssues = duplicateTitleCount > 0 || duplicateParagraphCount > 0 || results.wordCountIssues.length > 0 || results.maxConsecutiveDuplicates > 0;
            
            const report = `# Comprehensive 5000 Chapter Test Report

## Test Information
- **Test Date**: ${new Date().toISOString()}
- **Total Chapters**: ${results.totalChapters}
- **Duration**: ${(results.performance.duration / 1000).toFixed(2)} seconds
- **Average Time per Chapter**: ${(results.performance.duration / TOTAL_CHAPTERS).toFixed(2)}ms

## Summary

| Metric | Value | Status |
|--------|-------|--------|
| Total Chapters Generated | ${results.totalChapters} | ‚úÖ |
| Unique Titles | ${results.duplicateTitles.length} | ‚úÖ |
| Duplicate Titles | ${duplicateTitleCount} | ${duplicateTitleCount > 0 ? '‚ùå' : '‚úÖ'} |
| Max Consecutive Duplicates | ${results.maxConsecutiveDuplicates} | ${results.maxConsecutiveDuplicates > 0 ? '‚ùå' : '‚úÖ'} |
| Unique Paragraphs | ${Object.keys(results.paragraphCounts).length} | ‚úÖ |
| Duplicate Paragraphs | ${duplicateParagraphCount} | ${duplicateParagraphCount > 0 ? '‚ùå' : '‚úÖ'} |
| Word Count Issues (< 1000 words) | ${results.wordCountIssues.length} | ${results.wordCountIssues.length > 0 ? '‚ùå' : '‚úÖ'} |
| Unique Arcs | ${results.arcProgression.length} | ‚úÖ |
| Chapter Types Used | ${Object.keys(results.chapterTypes).length} | ‚úÖ |
| Settings Used | ${Object.keys(results.settings).length} | ‚úÖ |
| Locations Used | ${results.locations.length} | ‚úÖ |

## Duplicate Titles
${duplicateTitles.length > 0 ? 
    duplicateTitles.slice(0, 30).map(([title, count]) => 
        \`- "\${title}" - \${count} occurrences\`
    ).join('\\n') + (duplicateTitles.length > 30 ? \`\\n- ... and \${duplicateTitles.length - 30} more\` : '') : 
    'None'}

## Duplicate Paragraphs
${duplicateParagraphs.length > 0 ?
    duplicateParagraphs.sort((a, b) => b[1] - a[1]).slice(0, 30).map(([para, count]) =>
        \`- "\${para}..." - \${count} occurrences\`
    ).join('\\n') + (duplicateParagraphs.length > 30 ? \`\\n- ... and \${duplicateParagraphs.length - 30} more\` : '') :
    'None'}

## Word Count Issues
${results.wordCountIssues.length > 0 ?
    results.wordCountIssues.slice(0, 50).map(issue =>
        \`- Chapter \${issue.chapter}: \${issue.wordCount} words - "\${issue.title}" (\${issue.type}, \${issue.setting})\`
    ).join('\\n') + (results.wordCountIssues.length > 50 ? \`\\n- ... and \${results.wordCountIssues.length - 50} more\` : '') :
    'None'}

## Chapter Types Distribution
${Object.entries(results.chapterTypes).sort((a, b) => b[1] - a[1]).map(([type, count]) => {
    const percent = ((count / results.totalChapters) * 100).toFixed(2);
    return \`- \${type}: \${count} (\${percent}%)\`;
}).join('\\n')}

## Settings Distribution
${Object.entries(results.settings).sort((a, b) => b[1] - a[1]).map(([setting, count]) => {
    const percent = ((count / results.totalChapters) * 100).toFixed(2);
    return \`- \${setting}: \${count} (\${percent}%)\`;
}).join('\\n')}

## Arc Progression
${results.arcProgression.map((arc, index) => \`\${index + 1}. \${arc}\`).join('\\n')}

## Stat Progression (Sample every 100 chapters)
Chapter | Level | HP | MP | Blood Essence | STR | AGI | INT
${results.statProgression.map(stat => 
    \`\${stat.chapter} | \${stat.level} | \${stat.hp} | \${stat.mp} | \${stat.bloodEssence} | \${stat.str} | \${stat.agi} | \${stat.int}\`
).join('\\n')}

## Final Verdict
${hasIssues ? '‚ö†Ô∏è ISSUES FOUND' : '‚úÖ ALL TESTS PASSED'}

${!hasIssues ? 
    '‚úÖ No duplicate titles found\\n‚úÖ No consecutive duplicate titles\\n‚úÖ No duplicate paragraphs found\\n‚úÖ All chapters meet minimum word count (1000 words)\\n‚úÖ Arc progression working correctly\\n‚úÖ Stat progression working correctly\\n‚úÖ Chapter types distributed correctly\\n‚úÖ Settings distributed correctly\\n‚úÖ Performance acceptable' :
    (duplicateTitleCount > 0 ? \`‚ö†Ô∏è \${duplicateTitleCount} duplicate titles found\\n\` : '') +
    (results.maxConsecutiveDuplicates > 0 ? \`‚ö†Ô∏è \${results.maxConsecutiveDuplicates} consecutive duplicate titles found\\n\` : '') +
    (duplicateParagraphCount > 0 ? \`‚ö†Ô∏è \${duplicateParagraphCount} duplicate paragraphs found\\n\` : '') +
    (results.wordCountIssues.length > 0 ? \`‚ö†Ô∏è \${results.wordCountIssues.length} chapters below minimum word count\` : '')
}
`;
            
            const blob = new Blob([report], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'test-5000-results.md';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>